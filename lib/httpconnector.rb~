class HTTPConnector
	attr_reader :url, :errors, :response
	#takes a url string (generated by user), performs some validations and fixes
	#and then attempts to actually get the response 

	def initialize(url)
		@url = url
		@errors = []
		fix_scheme_and_path
		get_response unless @errors.size > 0
	end

	#user may input something like 'www.google.com', which isn't a valid URL
	#but is easy enough to fix using the URI parser
	def fix_scheme_and_path
		begin
			uri = URI.parse(@url)
			unless uri.scheme 	
				@url = "http://" + @url 
				uri = URI.parse(@url) 
			end	
			if uri.path == ""
				@url = @url + "/"
			end
		rescue URI::InvalidURIError => e
			@errors << "couldn't access that URL: " + e 	
		end
	end

	#connect and store the response -- function is called recursively 
	#if redirect is received, up to 10 redirects where it errors out to avoid redirect loops
	def get_response(depth = 0)
		if depth > 9
			@errors << "redirected too many times."
		end
		begin
			uri = URI.parse(@url)

			http = Net::HTTP.new(uri.host, uri.port)

			#using a pregenerated certificate for verification, a bad idea if this were a real app
			#but closer to correct than just turning verification off entirely 	
			if uri.scheme == "https"
				http.use_ssl = true
				http.verify_mode = OpenSSL::SSL::VERIFY_PEER
				http.ca_file = File.join(File.dirname(__FILE__), "cacert.pem")
			end


			http.start do
				http.request_get(uri.path) do |res|
					case res
					when Net::HTTPSuccess then
						@response = res
					when Net::HTTPRedirection then
						@url = res['location']	
						get_response(depth + 1)
					else
						@errors << "could not access that page, got response #{res.code}: #{res.message}"		
					end


				end
			end
		rescue Errno::ECONNREFUSED => e
			@errors << "couldn't access that URL: " + e 	
		end
	end
end
